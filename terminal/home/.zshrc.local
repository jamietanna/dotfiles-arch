## Zsh Vi-Mode
# Allow us to use colours, as below
autoload -U colors && colors

# Use Vi-keybindings
bindkey -v
# Disable lag - 0.1s
export KEYTIMEOUT=1

# Set up a right prompt to display when we're in normal mode
function zle-line-init zle-keymap-select {
	VIM_PROMPT="%{$fg_bold[red]%} [% NORMAL ]% %{$reset_color%}"
	RPS1="${${KEYMAP/vicmd/$VIM_PROMPT}/(main|viins)/} $EPS1"
	zle reset-prompt
}
# Actually hook it in
zle -N zle-line-init
zle -N zle-keymap-select

# And allow us to reverse search history
bindkey '^r' history-incremental-search-backward
bindkey '^a' beginning-of-line
bindkey '^e' end-of-line
## End

zstyle ':completion:*' matcher-list '' 'm:{a-z}={A-Z}' 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=* l:|=*'

export PATH="$PATH:$HOME/bin"

. ~/.githelpers

function mkd () {
	mkdir -p "$1" && cd "$1"
}

# Remove trailing whitespace from file(s)
function rmws () {
	# make sure our symlinks - i.e. config files - are followed
	# TODO maybe warn?
	sed --follow-symlinks -i 's/[ \t]*$//' "$@"
}
# -----------------------------------------------------------------------------
# => Use customised dircolors
# 	Use our own, preferred dircolors, and make sure that zsh uses them, too
# -----------------------------------------------------------------------------
# {{{
# don't like `eval` but unfortunately we have to use it here
eval $(dircolors $HOME/.dir_colors)
# ensure zsh's autocomplete uses the same colours as our `LS_COLORS`
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
# }}}

. $HOME/.Xresourceshelper

function str_contains() {
	# http://stackoverflow.com/questions/2829613/how-do-you-tell-if-a-string-contains-another-string-in-unix-shell-scripting
	string="$1"
	substring="$2"
	if test "${string#*$substring}" != "$string"
	then
		return 0    # $substring is in $string
	else
		return 1    # $substring is not in $string
	fi
}


[[ -e $HOME/.wksp.zsh ]] && . $HOME/.wksp.zsh



# force 256 colour mode, so we get the correct output in i.e. Vim
alias tmux="tmux -2"
