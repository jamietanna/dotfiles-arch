## Zsh Vi-Mode
# Allow us to use colours, as below
autoload -U colors && colors

# Use Vi-keybindings
bindkey -v
# Disable lag - 0.1s
export KEYTIMEOUT=1

# Set up a right prompt to display when we're in normal mode
function zle-line-init zle-keymap-select {
	VIM_PROMPT="%{$fg_bold[red]%} [% NORMAL ]% %{$reset_color%}"
	RPS1="${${KEYMAP/vicmd/$VIM_PROMPT}/(main|viins)/} $EPS1"
	zle reset-prompt
}
# Actually hook it in
zle -N zle-line-init
zle -N zle-keymap-select

# And allow us to reverse search history
bindkey '^r' history-incremental-search-backward
bindkey '^a' beginning-of-line
bindkey '^e' end-of-line
## End

zstyle ':completion:*' matcher-list '' 'm:{a-z}={A-Z}' 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=* l:|=*'

export PATH="$PATH:$HOME/bin"

alias gc="git commit"
alias gst="git status"
alias gp="git push"
alias gco="git checkout"
alias gd="git diff"
alias gdc="git diff --cached"
alias ga="git add"
alias gr="git remote"
alias glog="git log --stat"

# Stolen from https://github.com/garybernhardt/dotfiles/blob/2c2a757f4abd406f6b4e1b328b6382d37f7f9036/.githelpers
function pretty_git_log () {
	HASH="%C(yellow)%h%Creset"
	RELATIVE_TIME="%Cgreen(%ar)%Creset"
	AUTHOR="%C(bold blue)<%an>%Creset"
	REFS="%C(bold red)%d%Creset"
	SUBJECT="%s"

	FORMAT="$HASH}$RELATIVE_TIME}$AUTHOR}$REFS $SUBJECT"

	git log --graph --pretty="tformat:${FORMAT}" $* |
		# Replace (2 years ago) with (2 years)
		sed -Ee 's/(^[^<]*) ago\)/\1)/' |
		# Replace (2 years, 5 months) with (2 years)
		sed -Ee 's/(^[^<]*), [[:digit:]]+ .*months?\)/\1)/' |
		# Line columns up based on } delimiter
		column -s '}' -t |
		# Color merge commits specially
		sed -Ee "s/(Merge (branch|remote-tracking branch|pull request) .*$)/$(printf "\033[91m")\1$(printf "\033[0m")/" |
		# Page only if we're asked to.
		if [ -n "$GIT_NO_PAGER" ]; then
			cat
		else
			# Page only if needed.
			less --quit-if-one-screen --no-init --RAW-CONTROL-CHARS --chop-long-lines
		fi
}

alias glg="pretty_git_log"

function mkd () {
	mkdir -p $1 && cd $1
}

# Remove trailing whitespace from file(s)
function rmws () {
	# make sure our symlinks - i.e. config files - are followed
	# TODO maybe warn?
	sed --follow-symlinks -i 's/[ \t]*$//' "$@"
}

# get to the top of our git repo
alias gitroot='git rev-parse --show-toplevel'
alias groot='cd $(gitroot)'

# don't like `eval` but have to use it here
# by default, the colours for 777 dirs is unreadable (i.e. on an NTFS volume) -
# amend it here to ensure that we can actually read the output
eval $(dircolors $HOME/.dir_colors)
# ensure zsh's autocomplete uses the same colours as our `LS_COLORS`
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}

. $HOME/.Xresourceshelper

WORKSPACE_ROOT="$HOME/workspaces"

wksp () {
	workspace_location="$WORKSPACE_ROOT/$1"

	if [[ -z "$1" ]];
	then
		echo -e "\033[91mERROR: No workspace name given\033[0m"
		return 1
	fi

	if [[ ! -e "$workspace_location" ]];
	then
		echo -e "\033[93mWorkspace \`$1\` does not exist. Creating now...\033[0m"
		mkdir -p "$workspace_location"
	fi

	cd "$workspace_location"
}

function str_contains() {
	# http://stackoverflow.com/questions/2829613/how-do-you-tell-if-a-string-contains-another-string-in-unix-shell-scripting
	string="$1"
	substring="$2"
	if test "${string#*$substring}" != "$string"
	then
		return 0    # $substring is in $string
	else
		return 1    # $substring is not in $string
	fi
}

###
# display a different prompt when we're inside our workspaces - namely one that
# doesn't include the full workspace path

function workspace_prompt () {
	if str_contains "$(pwd)" "${WORKSPACE_ROOT}";
	then
		local curr_path
		local workspace_path
		local workspace_name
		curr_path="$(pwd)"
		workspace_path="${curr_path//${WORKSPACE_ROOT}\//}"
		workspace_name=$(echo ${workspace_path} | sed 's/\([^/]*\).*/\1/g')

		REPLY="W:$workspace_name "
	else
		REPLY=""
	fi
}

function path_wksp_prompt () {
	local curr_path
	local workspace_name
	local workspace_path

	if str_contains "$(pwd)" "${WORKSPACE_ROOT}";
	then
		curr_path="$(pwd)"
		workspace_path="${curr_path//${WORKSPACE_ROOT}\//}"
		workspace_name=$(echo ${workspace_path} | sed 's/\([^/]*\).*/\1/g')
		if [[ "$workspace_path" == "$workspace_name" ]];
		then
			# if we're at the top of the workspace, then don't output where we are
			# as we'll already have `W:<wksp>` displayed
			REPLY=""
		else
			# otherwise, display the path, ignoring the workspace name, for 40 characters,
			# taking care to truncate with a '..' if over that length
			REPLY="%40<..<${workspace_path/$workspace_name\//}%<< "
		fi
		# REPLY="${workspace_path} "

		# REPLY="%40<..<%~%<< "
	else
		REPLY="%40<..<%~%<< "
	fi
}

grml_theme_add_token path_wksp -f path_wksp_prompt '%B' '%b'
grml_theme_add_token wksp_indicator -f workspace_prompt '%B%F{red}' '%f%b'
### end
zstyle ':prompt:grml:left:setup' items rc change-root \
									user at host wksp_indicator path_wksp vcs percent

# http://unix.stackexchange.com/a/65071
compdef '_path_files -/ -W $WORKSPACE_ROOT' wksp

# force 256 colour mode, so we get the correct output in i.e. Vim
alias tmux="tmux -2"
